LEGEND:
# - done
~ - partial
? - problems
@ - stupid

BUG LOG:

?2. need for implicit conversion to value from initializer list -- difficulties
6. move collection map to default map object

defects:

#8. fix std::move semantics on instantiate collection
#20. when range/proxy get's clobbered it should throw an error trying to reiterate
#25. move CollectionManipulator to templatious instead of templatious::manip namespace
#~35. we can't chain functional calls to, for instance, .insert for packs (const correctness error, val is const)
#45. SF::seq when used as rvalue only receives const iterator... maybe it should receive copies of normal iterator?
#46. tweak seq to only return one type of iterator

features:

1. findIter @ CollectionManipulator needs comparator support
#7. virtual collection wrapper
10. tune map object
#11. loops
#12. quadro function
#13. lambda cat
#14. static array container (like vector)
#15. foreach
#16. traverse static arrays with foreach
#17. adapters for StaticVector HybridVector
18. variadic template function to call function on var arg [ t(f,a1,a2,a3...)]
#19. pick range from ANY collection to be used as collection
#21. proxies
#22. permissions for collections (DA BIG ONE)
#24. pack arguments into packs
#29. SM::edit (traverse and process every element) ------> replaced by SM::foreach
#30. extend SM::set to set simple vars as well
#31. convenience insert function
#32. insert within (in between existing packs one level)
#33. repeaters (repeat collections)
#34. distribute from pack to collection and vice versa
#36. pack repeat
#37. add pack to collection (SA::add)
#38. callEach should process collections too (optionally)
#41. transform packs within one by one
#42. transformation on add methods
#43. return from callEach/distribute to stop traversal
#44. decorate functor - make few functors from one as decorator
@47. make recursive sequence generator from lamba [ FOLD IS BETTER ]
#48. pair functors - do/undo stuff
#49. set ignore return val
#50. static vector splitter from bigger array
#51. create one time traversable structure, so that begin would be advancing
#53. encapsulate functor which calls pack
#54. quadro return times traversed
#55. dummy var which can be assigned anything
#56. proxy classes should use storage policy for functions and collections
@57. MULTIRATOR!! [ RETARDED ]
#58. select - type exchange collection
#59. make static array looser (eliminate constant only size knowledge)
#60. seqR - sequence repeat same value // - repS
#61. storage policy for match functor. partial - should be customized
62. iterator dump - useful for proxies
#63. cversions of proxy methods - copy instead of proxy
#64. fold
65. inspect
#66. pack transform should take functor or shouldn't be left at all...
#67. matchFunctor checked composition?
#70. are collections equal algorithm.
#71. forall function
#72. exists function

remove:
#68. logic functors - useless
69. remove map adapter - maybe leave for future,
    no need if it's half done

compatibility:

#3. const traverse and mold to one
#5. da empty initializer problem (std::map takes std::less function which uses empty constructor)
#4. fix comparator specializations (sortedAdd)
#27. compile in clang
#39. drop TypeSelector and use std::conditional
#40. give packs policies to decide how to store variables
#52. rvalue storage policy is never used unless we call it with decltype, not template parameter
66. make size return long, not int

perfection:
9. add const qualifiers to comparators
#23. replace asserts with thrown exceptions
#26. rename loopL/loopI to seqI/seqL + add seqR (sequence repeat)
#28. rename value_type etc. in adapter to camel case (no hybrid conventions...)
#51. rewrite erase function for filter to simply replace iterator instead of new collection
